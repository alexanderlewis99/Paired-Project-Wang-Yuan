lake <- read.csv("http://math.carleton.edu/kstclair/data/BergenData.csv")
hist(lake$distance, main = "detection distances (meters)")
summary(lake)
lake[1:5,1:5]
lake[1:10,1:5]
lake[1:77,1:5]
lake[1:77,1:7]
lake$distance
var(lake$distance)
sd(lake$distance)
sqrt(0.05998156)
sqrt(0.05)
n <- 100 # sample size
sigma <- 0.05 # value of sigma
x <- abs(rnorm(n,0,sigma))   # generating half normal random sample
x
x <- abs(rnorm(n,0,sigma))   # generating half normal random sample
x <- abs(rnorm(n,0,sigma))   # generating half normal random sample
x
x^2
pi()
pi
est_mle[i] <- sum(x^2)/n # MLE formula
est_mle <- list()
est_mom <- list()
i <- 1
est_mle[i] <- sum(x^2)/n # MLE formula
est_mom[i] <- mean(x)^2*pi*/2 # MoM formula
est_mom[i] <- mean(x)^2*pi/2 # MoM formula
est_mom
est_mle
qgamma(0.5)
qgamma(0.5,shape = n/2, 1/(2*sigma^2))
sigma
qgamma(0.5,shape = n/2, 1/(2*sigma^2))
qgamma(0.1,shape = n/2, 1/(2*sigma^2))
qgamma(0.001,shape = n/2, 1/(2*sigma^2))
qgamma(0.975,shape = n/2, 1/(2*sigma^2))
qgamma(0.025,shape = n/2, 1/(2*sigma^2))
q_0.975 <- qgamma(0.975,shape = n/2, 1/(2*sigma^2))
q_0.025 <- qgamma(0.025,shape = n/2, 1/(2*sigma^2))
q_0.975
q_0.025
mle_lower[i] <- q_0.975/(2*x_bar)
# based on exact MLE CI (part d)
x_bar <- mean(x)
q_0.975/(2*x_bar)
q_0.025/(2*x_bar)
mle_lower[i] <- x_bar/(2*q_0.975)
x_bar/(2*q_0.975)
x_bar/(2*q_0.025)
q_0.975
q_0.025
x_bar/(2*q_0.975)
x_bar/(2*q_0.025)
qa
N <- 10^5
my.boot <- numeric(N)
for(i in 1:N)
{
s <- sample(x, 10, relpace = TRUE) # draw resamples
my.boot[i] <- var(s) # compute variance, store in my.boot
}
N <- 10^5
my.boot <- numeric(N)
for(i in 1:N)
{
s <- sample(x, 10, replace = TRUE) # draw resamples
my.boot[i] <- var(s) # compute variance, store in my.boot
}
quantile(my.boot, c(0.025))
quantile(my.boot, c(0.975))
N <- 10^5
my.boot <- numeric(N)
for(i in 1:N)
{
s <- sample(x, 100, replace = TRUE) # draw resamples
my.boot[i] <- var(s) # compute variance, store in my.boot
}
quantile(my.boot, c(0.025))
quantile(my.boot, c(0.975))
length(x)
sd(x)
0.5^2
x_bar/(2*q_0.975)
x_bar/(2*q_0.025)
rm(my.boot)
N <- 10^5
my.boot <- numeric(N)
for(i in 1:N)
{
s <- sample(x, 100, replace = TRUE) # draw resamples
my.boot.MLE[i] <- sum(s^2)/n # compute MLE variance, store in my.boot
my.boot.MoM[i] <- mean(s)^2*pi/2 # compute MoM variance, store in my.boot
}
}
rm(my.boot)
N <- 10^5
my.boot.MLE <- numeric(N)
my.boot.MoM <- numeric(N)
for(i in 1:N)
{
s <- sample(x, 100, replace = TRUE) # draw resamples
my.boot.MLE[i] <- sum(s^2)/n # compute MLE variance, store in my.boot
my.boot.MoM[i] <- mean(s)^2*pi/2 # compute MoM variance, store in my.boot
}
mle_boot_lower[i] <- quantile(my.boot.MLE, c(0.025))
i
i <- 1
set.seed(0)
N <- 10^5
my.boot.MLE <- numeric(N)
my.boot.MoM <- numeric(N)
for(j in 1:N)
{
s <- sample(x, 100, replace = TRUE) # draw resamples
my.boot.MLE[j] <- sum(s^2)/n # compute MLE variance, store in my.boot
my.boot.MoM[j] <- mean(s)^2*pi/2 # compute MoM variance, store in my.boot
}
mle_boot_lower <- list()
mle_boot_lower[i] <- quantile(my.boot.MLE, c(0.025))
mle_boot_upper[i] <- quantile(my.boot.MLE, c(0.975))
mle_boot_lower <- list()
mle_boot_upper <- list()
mle_boot_lower[i] <- quantile(my.boot.MLE, c(0.025))
mle_boot_upper[i] <- quantile(my.boot.MLE, c(0.975))
# CI based on bootstrapping the MoM
mom_boot_lower <- list()
mom_boot_upper <- list()
mom_boot_lower[i] <- quantile(my.boot.MoM, c(0.025))
mom_boot_upper[i] <- quantile(my.boot.MoM, c(0.975))
mle_boot_lower
mle_boot_upper
mom_boot_lower
mom_boot_upper
sqrt(0.05)
0.05^2
10^5*10^5
set.seed(0)
K <- 10^2
est_mle <- list()
est_mom <- list()
mle_boot_lower <- list()
mle_boot_upper <- list()
mom_boot_lower <- list()
mom_boot_upper <- list()
for(i in 1:K){
x <- abs(rnorm(n,0,sigma))   # generating half normal random sample
est_mle[i] <- sum(x^2)/n # MLE formula
est_mom[i] <- mean(x)^2*pi/2 # MoM formula
q_0.975 <- qgamma(0.975,shape = n/2, 1/(2*sigma^2))
q_0.025 <- qgamma(0.025,shape = n/2, 1/(2*sigma^2))
# based on exact MLE CI (part d)
x_bar <- mean(x)
mle_lower[i] <- x_bar/(2*q_0.975)
# based on exact MLE CI (part d)
mle_upper[i] <- x_bar/(2*q_0.025)
# CI based on bootstrapping the MLE
set.seed(0)
N <- 10^4
my.boot.MLE <- numeric(N)
my.boot.MoM <- numeric(N)
for(j in 1:N)
{
s <- sample(x, 100, replace = TRUE) # draw resamples
my.boot.MLE[j] <- sum(s^2)/n # compute MLE variance, store in my.boot
my.boot.MoM[j] <- mean(s)^2*pi/2 # compute MoM variance, store in my.boot
}
mle_boot_lower[i] <- quantile(my.boot.MLE, c(0.025))
mle_boot_upper[i] <- quantile(my.boot.MLE, c(0.975))
# CI based on bootstrapping the MoM
mom_boot_lower[i] <- quantile(my.boot.MoM, c(0.025))
mom_boot_upper[i] <- quantile(my.boot.MoM, c(0.975))
}
set.seed(0)
K <- 10^2
est_mle <- list()
est_mom <- list()
mle_lower <- list()
mle_upper <- list()
mle_boot_lower <- list()
mle_boot_upper <- list()
mom_boot_lower <- list()
mom_boot_upper <- list()
for(i in 1:K){
x <- abs(rnorm(n,0,sigma))   # generating half normal random sample
est_mle[i] <- sum(x^2)/n # MLE formula
est_mom[i] <- mean(x)^2*pi/2 # MoM formula
q_0.975 <- qgamma(0.975,shape = n/2, 1/(2*sigma^2))
q_0.025 <- qgamma(0.025,shape = n/2, 1/(2*sigma^2))
# based on exact MLE CI (part d)
x_bar <- mean(x)
mle_lower[i] <- x_bar/(2*q_0.975)
# based on exact MLE CI (part d)
mle_upper[i] <- x_bar/(2*q_0.025)
# CI based on bootstrapping the MLE
set.seed(0)
N <- 10^4
my.boot.MLE <- numeric(N)
my.boot.MoM <- numeric(N)
for(j in 1:N)
{
s <- sample(x, 100, replace = TRUE) # draw resamples
my.boot.MLE[j] <- sum(s^2)/n # compute MLE variance, store in my.boot
my.boot.MoM[j] <- mean(s)^2*pi/2 # compute MoM variance, store in my.boot
}
mle_boot_lower[i] <- quantile(my.boot.MLE, c(0.025))
mle_boot_upper[i] <- quantile(my.boot.MLE, c(0.975))
# CI based on bootstrapping the MoM
mom_boot_lower[i] <- quantile(my.boot.MoM, c(0.025))
mom_boot_upper[i] <- quantile(my.boot.MoM, c(0.975))
}
mean(mom_boot_upper)
mle_boot_upper
asdf <- c()
asdf[1] <- 2
asdf[3] <- 2
asdf
set.seed(0)
K <- 10^4
est_mle <- c()
est_mom <- c()
mle_lower <- c()
mle_upper <- c()
mle_boot_lower <- c()
mle_boot_upper <- c()
mom_boot_lower <- c()
mom_boot_upper <- c()
for(i in 1:K){
x <- abs(rnorm(n,0,sigma))   # generating half normal random sample
est_mle[i] <- sum(x^2)/n # MLE formula
est_mom[i] <- mean(x)^2*pi/2 # MoM formula
q_0.975 <- qgamma(0.975,shape = n/2, 1/(2*sigma^2))
q_0.025 <- qgamma(0.025,shape = n/2, 1/(2*sigma^2))
# based on exact MLE CI (part d)
x_bar <- mean(x)
mle_lower[i] <- x_bar/(2*q_0.975)
# based on exact MLE CI (part d)
mle_upper[i] <- x_bar/(2*q_0.025)
# CI based on bootstrapping the MLE
set.seed(0)
N <- 10^4
my.boot.MLE <- numeric(N)
my.boot.MoM <- numeric(N)
for(j in 1:N)
{
s <- sample(x, 100, replace = TRUE) # draw resamples
my.boot.MLE[j] <- sum(s^2)/n # compute MLE variance, store in my.boot
my.boot.MoM[j] <- mean(s)^2*pi/2 # compute MoM variance, store in my.boot
}
mle_boot_lower[i] <- quantile(my.boot.MLE, c(0.025))
mle_boot_upper[i] <- quantile(my.boot.MLE, c(0.975))
# CI based on bootstrapping the MoM
mom_boot_lower[i] <- quantile(my.boot.MoM, c(0.025))
mom_boot_upper[i] <- quantile(my.boot.MoM, c(0.975))
}
set.seed(0)
K <- 10^4
est_mle <- c()
est_mom <- c()
mle_lower <- c()
mle_upper <- c()
mle_boot_lower <- c()
mle_boot_upper <- c()
mom_boot_lower <- c()
mom_boot_upper <- c()
for(i in 1:K){
x <- abs(rnorm(n,0,sigma))   # generating half normal random sample
est_mle[i] <- sum(x^2)/n # MLE formula
est_mom[i] <- mean(x)^2*pi/2 # MoM formula
q_0.975 <- qgamma(0.975,shape = n/2, 1/(2*sigma^2))
q_0.025 <- qgamma(0.025,shape = n/2, 1/(2*sigma^2))
# based on exact MLE CI (part d)
x_bar <- mean(x)
mle_lower[i] <- x_bar/(2*q_0.975)
# based on exact MLE CI (part d)
mle_upper[i] <- x_bar/(2*q_0.025)
# CI based on bootstrapping the MLE
set.seed(0)
N <- 10^4
my.boot.MLE <- numeric(N)
my.boot.MoM <- numeric(N)
for(j in 1:N)
{
s <- sample(x, 100, replace = TRUE) # draw resamples
my.boot.MLE[j] <- sum(s^2)/n # compute MLE variance, store in my.boot
my.boot.MoM[j] <- mean(s)^2*pi/2 # compute MoM variance, store in my.boot
}
mle_boot_lower[i] <- quantile(my.boot.MLE, c(0.025))
mle_boot_upper[i] <- quantile(my.boot.MLE, c(0.975))
# CI based on bootstrapping the MoM
mom_boot_lower[i] <- quantile(my.boot.MoM, c(0.025))
mom_boot_upper[i] <- quantile(my.boot.MoM, c(0.975))
print(i)
}
set.seed(0)
K <- 10^2
est_mle <- c()
est_mom <- c()
mle_lower <- c()
mle_upper <- c()
mle_boot_lower <- c()
mle_boot_upper <- c()
mom_boot_lower <- c()
mom_boot_upper <- c()
for(i in 1:K){
x <- abs(rnorm(n,0,sigma))   # generating half normal random sample
est_mle[i] <- sum(x^2)/n # MLE formula
est_mom[i] <- mean(x)^2*pi/2 # MoM formula
q_0.975 <- qgamma(0.975,shape = n/2, 1/(2*sigma^2))
q_0.025 <- qgamma(0.025,shape = n/2, 1/(2*sigma^2))
# based on exact MLE CI (part d)
x_bar <- mean(x)
mle_lower[i] <- x_bar/(2*q_0.975)
# based on exact MLE CI (part d)
mle_upper[i] <- x_bar/(2*q_0.025)
# CI based on bootstrapping the MLE
set.seed(0)
N <- 10^4
my.boot.MLE <- numeric(N)
my.boot.MoM <- numeric(N)
for(j in 1:N)
{
s <- sample(x, 100, replace = TRUE) # draw resamples
my.boot.MLE[j] <- sum(s^2)/n # compute MLE variance, store in my.boot
my.boot.MoM[j] <- mean(s)^2*pi/2 # compute MoM variance, store in my.boot
}
mle_boot_lower[i] <- quantile(my.boot.MLE, c(0.025))
mle_boot_upper[i] <- quantile(my.boot.MLE, c(0.975))
# CI based on bootstrapping the MoM
mom_boot_lower[i] <- quantile(my.boot.MoM, c(0.025))
mom_boot_upper[i] <- quantile(my.boot.MoM, c(0.975))
print(i)
}
mean(est_mle)
mean(est_mom)
mean(mle_lower)
mean(mle_upper)
mean(mle_boot_lower)
mean(mle_boot_upper)
mean(mom_boot_lower)
mean(mom_boot_upper)
sqrt(0.05)
0.05^2
